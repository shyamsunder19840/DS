import base64
import io
import datetime
from typing import Optional

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

from endesive import pdf
from cryptography import x509
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.lib.colors import black
from PyPDF2 import PdfReader, PdfWriter

def create_signature_footer_advanced(Approver_Name:str):
    packet = io.BytesIO()
    can = canvas.Canvas(packet, pagesize=letter)
    footer_y = 25
    left_margin = 30
    can.setFont("Helvetica", 8)
    can.setFillColor(black)
    can.drawString(left_margin, footer_y + 20, "Digitally Signed By: " + Approver_Name)
    can.setFont("Helvetica-Bold", 9)
    can.drawString(left_margin, footer_y + 10, "PROACTIVE DATA SYSTEMS PVT LTD")
    can.setFont("Helvetica", 7)
    current_date = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    can.drawString(left_margin, footer_y, f"Date: {current_date}")
    can.drawString(left_margin, footer_y - 8, "Location: New Delhi")
    can.save()
    packet.seek(0)
    return packet


def _load_private_key_from_b64(private_key_b64: str):
    key_bytes = base64.b64decode(private_key_b64)
    try:
        return serialization.load_pem_private_key(key_bytes, password=None, backend=default_backend())
    except ValueError:
        return serialization.load_der_private_key(key_bytes, password=None, backend=default_backend())


def _load_cert_from_b64(cert_b64: str):
    cert_bytes = base64.b64decode(cert_b64)
    try:
        return x509.load_pem_x509_certificate(cert_bytes, default_backend())
    except ValueError:
        return x509.load_der_x509_certificate(cert_bytes, default_backend())


def _load_chain_from_b64(chain_b64: str):
    if not chain_b64:
        return []
    chain_bytes = base64.b64decode(chain_b64)
    text = chain_bytes.decode("utf-8", errors="ignore")
    certs = []
    blocks = text.split("-----BEGIN CERTIFICATE-----")
    for b in blocks[1:]:
        body = b.split("-----END CERTIFICATE-----")[0]
        pem = "-----BEGIN CERTIFICATE-----" + body + "-----END CERTIFICATE-----\n"
        certs.append(x509.load_pem_x509_certificate(pem.encode("utf-8"), default_backend()))
    return certs


def create_signed_pdf_base64(Approver_Name: str,
                             input_pdf_base64: str,
                             private_key_base64: str,
                             certificate_base64: str,
                             ca_chain_base64: str = None) -> str | None:
    try:
        # Decode PDF
        input_pdf_bytes = base64.b64decode(input_pdf_base64)
        input_pdf_stream = io.BytesIO(input_pdf_bytes)

        # Load signing materials
        private_key = _load_private_key_from_b64(private_key_base64)
        cert = _load_cert_from_b64(certificate_base64)
        ca_chain = _load_chain_from_b64(ca_chain_base64)

        # Add footer
        original_reader = PdfReader(input_pdf_stream)
        final_writer = PdfWriter()
        signature_packet = create_signature_footer_advanced(Approver_Name)

        for original_page in original_reader.pages:
            page_packet = io.BytesIO(signature_packet.getvalue())
            signature_reader = PdfReader(page_packet)
            signature_page = signature_reader.pages[0]
            original_page.merge_page(signature_page)
            final_writer.add_page(original_page)

        intermediate_stream = io.BytesIO()
        final_writer.write(intermediate_stream)
        intermediate_stream.seek(0)
        data = intermediate_stream.read()

        # Signature dictionary
        date = datetime.datetime.utcnow().strftime("D:%Y%m%d%H%M%S+00'00'")
        signature_dict = {
            "sigflags": 3,
            "contact": "PROACTIVE DATA SYSTEMS PVT LTD",
            "location": "New Delhi",
            "reason": "Document Authentication and Verification",
            "signingdate": date,
            "signature": "PROACTIVE DATA SYSTEMS PVT LTD",
        }

        # Sign
        signature = pdf.cms.sign(
            data,
            signature_dict,
            private_key,
            cert,
            ca_chain,
            "sha256",
            None,
            None,
        )

        signed_pdf_bytes = data + signature
        return base64.b64encode(signed_pdf_bytes).decode("utf-8")
       

    except Exception as e:
        print(f"❌ Error: {str(e)}")
        import traceback
        traceback.print_exc()
        return None


# ---------- request/response models ----------
class SignRequest(BaseModel):
    Param_input_pdf_base64: str
    Param_Approver_Name: str
    
class SignResponse(BaseModel):
    signed_pdf_base64: str    

app = FastAPI()
@app.post("/",response_model=SignResponse)
def sign_pdf(req: SignRequest):
    private_key_base64 = "QmFnIEF0dHJpYnV0ZXMKICAgIGxvY2FsS2V5SUQ6IDAxIDAwIDAwIDAwIAogICAgZnJpZW5kbHlOYW1lOiB0ZS04YTExY2U4NC1mZDljLTRmODgtYjEzNy04NzRhZDM3ODIwYjAKICAgIE1pY3Jvc29mdCBDU1AgTmFtZTogTWljcm9zb2Z0IEVuaGFuY2VkIENyeXB0b2dyYXBoaWMgUHJvdmlkZXIgdjEuMApLZXkgQXR0cmlidXRlcwogICAgWDUwOXYzIEtleSBVc2FnZTogMTAgCi0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLQpNSUlFdmdJQkFEQU5CZ2txaGtpRzl3MEJBUUVGQUFTQ0JLZ3dnZ1NrQWdFQUFvSUJBUURWTGpwSUpOWkpvaC9ZCi90cE9LUGVjSnJKU2RVcmU4ZnFLMGlRTEs5RlJ1NDlmeHRBYXVURnppMlloQzcwR29QeWlXdS9kWWIrcTdWT1cKSUw2NzdjbnFaYk9BQ2ZFZExieUpUZEVraSthTXpMWTlRV2p4NUtJcUlhVmYxdTZyWmJUQWU1RjZYS3c5Vm5HNAphV0lxV0dDR1lNbGtwaEVLM0wrVitIK2VMSXB4b0NEa0l1L20rTHRoSTIrdTRkSTZHTGtWejZBRkhQM0U4Rjk5CmRmeldobXJoMERFT2dDTnRTbXhZV0Ezd2Y3VlRYSis0WHNxNk1pYkRpS3NYOFluV3FtUVRTRHYrWEx1RzBBZ3QKbkZtTDdUZVZwWjRjRVBwNklKMmdIc3BZNFgrblZSU1NmUkVzclg3dEZuTEczQWhjeHNURlZZVCsxR1drYWJvYgpyTE9kT3l6RkFnTUJBQUVDZ2dFQkFMYWJkSjBid05zdUh1MjMwTFFtNzRNNHVvTmJxWml6MnBOVFVrQ25kaFAyCi8rZGczQjRvQ0s0YStJN1NDVWRHVzJHUFYreGdzTmZ2bHl3QVBLR3FITTNGOUM1M1ZheFM0eThTRTFhazZBWXYKek9OSHhtZCtHMUxQbzJNbkx5WnVacGlDd0tqNS9TaEZoZ0FiZFZVa2d2cFlxZXFuUGUzNkRicWZOR0gvY1UvRgo5R3pKZ0ZneklKYmRod1NiZWY4dTc5UUpWVUhkVVlBaG1ndHhsWkZaNm5ORXlQNHVWSnF2aFhhMzRnTVpOR1VFCnMwanBZdnZscERVa3ZCbDFPdU4yREswMW9FRytYLzZGM1A4TUdEMEQ2N1N4bjF1NVcwL1Vua3R6aExEOVlkQisKbmdzL3owano0TVM0dU81VTZGYkQ2WkV1ZzdZczJlbGhkeWIvbDJTWTBma0NnWUVBNklPMlZZZG8xYTVuS1E0bQoxcjQrTjNpZUJCR2JqSnhUWWJSalZVVHBmWEhleE80cHY4MUJML3hISUk2SVVMYzkrWXNVWWcyQjYzZ2NjbVNvCnBBbXY1aUU2UHpJZHc2MytIekNIUUtsNXJBakY5RmdUOXlKK25IU3NNdGlwRHNQcTJhUnZTTXhyS3VQM3VSckgKN0VocXFtMjNwNW44UGNqejJVcTYrcVdUNW04Q2dZRUE2cmFWdG1ra0VvKzJjSHNOUmRiYU9tTjNNUm0zcUE2RwpJREVlc0ZqelRycGxiclAyaWh2SDVZejlwdzlnTXBlMy9SMDZBc3RHZXZYZWg5cnhkOVZHRk1FaHEvVW9PUjRRCkExTDVJeXJVZVNiVUs5V1dZRzI3V1h0b0tFMkhjQ1FhbHF3a09iMG5iS1lYM2t0NTZJaGFCWjJpS21LU0lRWnAKUXlRU3QrR1hHZ3NDZ1lCYkdCODdhdzI3aWRTSTFTNktPNGFNblFqcmR5cUY4RWtLb20yNFhvTkx6bTBFb25wZwoxcjJQV3p0U21nVDErcFNoUzhmMGttNHdIcUttZnFGRGd6Z1M1VG00d0ozQXFFNURVZlByZFhwaDJCNFdHTnZaCm12NFh0ZTR4RFlsT2E1dDdJVjBvSEU1d1ExZ3VnVHVLYXVTL1dMVDNTUEQyRStEVlpOM1VqVUpncVFLQmdDTTUKRVZDVmlMZE1YOW1UYmROOFFiV2ZkYVNsc2wwRENQZk54MGc1b1JIQWdUWlN4WDNHVzRKRVhWQnp5MERzYWMwUApWTVJVa3hnaXk2bGhudmtYeFhPWjVCNjFKTHNsbXN1VTZSUncrZi9RWnVqSkhjOE15Si9PR0R4c0hoWWpKT1pWCm9QNFZOOVJqUEpPOGllZnVobXZ2VXdXL1V5U25uS1paeElGWjFsNHZBb0dCQUtEeVFKbjA1dC9KbkpIWnpkNXkKZEVhaG9scml3MkVNajdSQTFVZEgyV0VmZ1VFTUQ2SUN2SXdxYzZlbHIwUW45cEVhOWU1bWJQU0E4R3g1ZkdzZQo2YWxJeThkRTNhbGxlb0tocDV1eEI5SVA4UWg1Z1FmN2VQVFNiZE1rc2xYTEhNM3BsNlNEdDlMNDRPeVJrTlN1CnA2S3hFaCtOS3NxeTRTTUxsV1c5Y01jbwotLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tCg=="
    certificate_base64 = "QmFnIEF0dHJpYnV0ZXMKICAgIGxvY2FsS2V5SUQ6IDAxIDAwIDAwIDAwIAogICAgMS4zLjYuMS40LjEuMzExLjE3LjMuNzE6IDQ0IDAwIDQ1IDAwIDUzIDAwIDRCIDAwIDU0IDAwIDRGIDAwIDUwIDAwIDJEIDAwIDQ3IDAwIDUwIDAwIDMzIDAwIDQyIDAwIDRGIDAwIDUyIDAwIDM3IDAwIDAwIDAwIAogICAgMS4zLjYuMS40LjEuMzExLjE3LjMuNzU6IDM5IDAwIDQzIDAwIDQ1IDAwIDQyIDAwIDQxIDAwIDQ1IDAwIDQxIDAwIDM5IDAwIDM1IDAwIDQxIDAwIDMzIDAwIDM2IDAwIDMwIDAwIDMxIDAwIDM1IDAwIDQzIDAwIDMxIDAwIDM5IDAwIDM4IDAwIDM2IDAwIDQ2IDAwIDM4IDAwIDMzIDAwIDM5IDAwIDM0IDAwIDM0IDAwIDM5IDAwIDM5IDAwIDQ0IDAwIDM3IDAwIDQzIDAwIDQ0IDAwIDVGIDAwIDAwIDAwIApzdWJqZWN0PUMgPSBJTiwgTyA9IFBST0FDVElWRSBEQVRBIFNZU1RFTVMgUFZUIExURCwgT1UgPSBGSU5BTkNFLCBwb3N0YWxDb2RlID0gMTEwMDIwLCBTVCA9IERFTEhJLCBzdHJlZXQgPSBTT1VUSCBERUxISSwgaG91c2VJZGVudGlmaWVyID0gMm5kIEZsb29yIEJsb2NrIEUgTlNJQyBUZWNobmljYWwgU2VydmljZXMgQ2VudGVyIE9raGxhIEluZHVzdHJpYWwgRXN0YXRlIFBoYXNlIElJSSwgc2VyaWFsTnVtYmVyID0gYjkxM2Y4MTg3MzQ5ZWJkZGI5OTVmOTA3NTcwYWM2MmQ0YzcwMGFlYWUwZTgxOWQzZTM3MDVhY2YzMzQwNTZmZSwgQ04gPSBEUyBQUk9BQ1RJVkUgREFUQSBTWVNURU1TIFBWVCBMVEQgMQppc3N1ZXI9QyA9IElOLCBPID0gZU11ZGhyYSBMaW1pdGVkLCBPVSA9IENlcnRpZnlpbmcgQXV0aG9yaXR5LCBDTiA9IGUtTXVkaHJhIFN1YiBDQSBmb3IgQ2xhc3MgMiBEb2N1bWVudCBTaWduZXIgMjAyMgotLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS0KTUlJR3N6Q0NCWnVnQXdJQkFnSUVBWXgwR2pBTkJna3Foa2lHOXcwQkFRc0ZBRENCZ1RFTE1Ba0dBMVVFQmhNQwpTVTR4R0RBV0JnTlZCQW9URDJWTmRXUm9jbUVnVEdsdGFYUmxaREVkTUJzR0ExVUVDeE1VUTJWeWRHbG1lV2x1Clp5QkJkWFJvYjNKcGRIa3hPVEEzQmdOVkJBTVRNR1V0VFhWa2FISmhJRk4xWWlCRFFTQm1iM0lnUTJ4aGMzTWcKTWlCRWIyTjFiV1Z1ZENCVGFXZHVaWElnTWpBeU1qQWVGdzB5TlRBME1ERXdPVEF5TVRGYUZ3MHlOekEwTURFdwpPVEF5TVRGYU1JSUJWVEVMTUFrR0ExVUVCaE1DU1U0eEp6QWxCZ05WQkFvVEhsQlNUMEZEVkVsV1JTQkVRVlJCCklGTlpVMVJGVFZNZ1VGWlVJRXhVUkRFUU1BNEdBMVVFQ3hNSFJrbE9RVTVEUlRFUE1BMEdBMVVFRVJNR01URXcKTURJd01RNHdEQVlEVlFRSUV3VkVSVXhJU1RFVU1CSUdBMVVFQ1JNTFUwOVZWRWdnUkVWTVNFa3hXekJaQmdOVgpCRE1UVWpKdVpDQkdiRzl2Y2lCQ2JHOWpheUJGSUU1VFNVTWdWR1ZqYUc1cFkyRnNJRk5sY25acFkyVnpJRU5sCmJuUmxjaUJQYTJoc1lTQkpibVIxYzNSeWFXRnNJRVZ6ZEdGMFpTQlFhR0Z6WlNCSlNVa3hTVEJIQmdOVkJBVVQKUUdJNU1UTm1PREU0TnpNME9XVmlaR1JpT1RrMVpqa3dOelUzTUdGak5qSmtOR00zTURCaFpXRmxNR1U0TVRsawpNMlV6TnpBMVlXTm1Nek0wTURVMlptVXhMREFxQmdOVkJBTVRJMFJUSUZCU1QwRkRWRWxXUlNCRVFWUkJJRk5aClUxUkZUVk1nVUZaVUlFeFVSQ0F4TUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUEKMVM0NlNDVFdTYUlmMlA3YVRpajNuQ2F5VW5WSzN2SDZpdElrQ3l2UlVidVBYOGJRR3JreGM0dG1JUXU5QnFEOApvbHJ2M1dHL3F1MVRsaUMrdSszSjZtV3pnQW54SFMyOGlVM1JKSXZtak15MlBVRm84ZVNpS2lHbFg5YnVxMlcwCndIdVJlbHlzUFZaeHVHbGlLbGhnaG1ESlpLWVJDdHkvbGZoL25peUtjYUFnNUNMdjV2aTdZU052cnVIU09oaTUKRmMrZ0JSejl4UEJmZlhYODFvWnE0ZEF4RG9BamJVcHNXRmdOOEgrMVUxeWZ1RjdLdWpJbXc0aXJGL0dKMXFwawpFMGc3L2x5N2h0QUlMWnhaaSswM2xhV2VIQkQ2ZWlDZG9CN0tXT0YvcDFVVWtuMFJMSzErN1JaeXh0d0lYTWJFCnhWV0UvdFJscEdtNkc2eXpuVHNzeFFJREFRQUJvNElDV2pDQ0FsWXdId1lEVlIwakJCZ3dGb0FVcS8rdXcxMm0KMHUwOEZBRThWUjFyVTE3cXkrMHdIUVlEVlIwT0JCWUVGUGhCVjR0ejRpUkR1NEJBWkxIU2xSck1lY2JZTUF3RwpBMVVkRXdFQi93UUNNQUF3RGdZRFZSMFBBUUgvQkFRREFnYkFNQ01HQTFVZEVRUWNNQnFCR0VGRFEwOVZUbFJUClFGQlNUMEZEVkVsV1JTNURUeTVKVGpBMEJnTlZIU1VFTFRBckJnZ3JCZ0VGQlFjREJBWUtLd1lCQkFHQ053b0QKREFZSktvWklodmN2QVFFRkJnZ3JCZ0VGQlFjREFqQ0IwZ1lEVlIwZ0JJSEtNSUhITUMwR0JtQ0NaR1FDQWpBagpNQ0VHQ0NzR0FRVUZCd0lDTUJVYUUwTnNZWE56SURJZ1EyVnlkR2xtYVdOaGRHVXdSQVlHWUlKa1pBb0JNRG93Ck9BWUlLd1lCQlFVSEFnSXdMQm9xVDNKbllXNXBjMkYwYVc5dVlXd2dSRzlqZFcxbGJuUWdVMmxuYm1WeUlFTmwKY25ScFptbGpZWFJsTUZBR0IyQ0NaR1FCQ0FJd1JUQkRCZ2dyQmdFRkJRY0NBUlkzYUhSMGNEb3ZMM2QzZHk1bApMVzExWkdoeVlTNWpiMjB2Y21Wd2IzTnBkRzl5ZVM5amNITXZaUzFOZFdSb2NtRmZRMUJUTG5Ca1pqQjhCZ2dyCkJnRUZCUWNCQVFSd01HNHdKQVlJS3dZQkJRVUhNQUdHR0doMGRIQTZMeTl2WTNOd0xtVXRiWFZrYUhKaExtTnYKYlRCR0JnZ3JCZ0VGQlFjd0FvWTZhSFIwY0RvdkwzZDNkeTVsTFcxMVpHaHlZUzVqYjIwdmNtVndiM05wZEc5eQplUzlqWVdObGNuUnpMMlZ0WTJ3eVpITXlNREl5TG1OeWREQklCZ05WSFI4RVFUQS9NRDJnTzZBNWhqZG9kSFJ3Ck9pOHZkM2QzTG1VdGJYVmthSEpoTG1OdmJTOXlaWEJ2YzJsMGIzSjVMMk55YkhNdlpXMWpiREprY3pJd01qSXUKWTNKc01BMEdDU3FHU0liM0RRRUJDd1VBQTRJQkFRQWovNWlBVlVyZXo4MUNNUHFyWFJOZS90T0UvZ1FVbFJGaAo1Ym1xb1loaUJGRjNvSGpTMW4xL3BjTGdISGFuU0FiQlRVMjdxa2NjNFBLTmpxSU14MFIwRGZJamxjaGwrM09rClpHQVMvWXdsT3VUNU1hREtmWk9BQ3l2cWFacStIa0xEbHA0K2tEUnNHUnpEVjJtTFlFUlAzOHZEZHdlcXBWRmMKREQ3Z2ZMRmEvWklHWVNadnZmRHphT0Q1TFhSK01VbkhtK1JYeHZlRDZGT0ZGNEwxOGw4MEU0UzlOSG1qRy9SSApHUisycVllemxId0hZc0o5WHhmSHJwSm0zc0xvMTVVcmFMVXhoTHE5Z1ZQblhRd25saVF2V1RJcThpNzlTQVROClltc1hvSlBONUZwRFM5cHJwV2VyUHRDL1FYc2RFV3M1L0loMExrMnkzQnNtT3hQb2Z2bFUKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo="
    ca_chain_base64 = "QmFnIEF0dHJpYnV0ZXM6IDxFbXB0eSBBdHRyaWJ1dGVzPgpzdWJqZWN0PUMgPSBJTiwgTyA9IEluZGlhIFBLSSwgQ04gPSBDQ0EgSW5kaWEgMjAyMgppc3N1ZXI9QyA9IElOLCBPID0gSW5kaWEgUEtJLCBDTiA9IENDQSBJbmRpYSAyMDIyCi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLQpNSUlGTkRDQ0F4eWdBd0lCQWdJUWRpUXo2OXNtZGxxRllNMEtxQy9oRnpBTkJna3Foa2lHOXcwQkFRc0ZBREE2Ck1Rc3dDUVlEVlFRR0V3SkpUakVTTUJBR0ExVUVDaE1KU1c1a2FXRWdVRXRKTVJjd0ZRWURWUVFERXc1RFEwRWcKU1c1a2FXRWdNakF5TWpBZUZ3MHlNakF5TURJeE1qQTBNemRhRncwME1qQXlNREl4TWpBME16ZGFNRG94Q3pBSgpCZ05WQkFZVEFrbE9NUkl3RUFZRFZRUUtFd2xKYm1ScFlTQlFTMGt4RnpBVkJnTlZCQU1URGtORFFTQkpibVJwCllTQXlNREl5TUlJQ0lqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FnOEFNSUlDQ2dLQ0FnRUF2M0VCdWRXQzhIWTAKb1N3dEpaQ3FwalFUR3BFZXdsM0VkRHFVT1JWMHFvRnA3OG1kUi92dUFUWEk4M0c3bkY5Ukx2bU5qZ1FnS3IvYgpNeDZnUE80WTU3Yk1qQXNnd0V6bGVGY2xaa2Evc3FjNjhpTjVyUzNodWhyQ1g2TUVJTkx5RE9RNzFNUkE3R0pDCmFOTDZFM2oxNDM4ZVR1MDExbWxpa2VaWUJka2h2ZnBBVmpDdzkwdzh3Y1dEbXF4NjZZNTYxVC9SaVh5ejJ1RWgKQkJaQUQ0M2dWNThlWFN0T2VPVHdBekVaWU1ybXAyMzJHZm1RS2FiWVJmZElSdXMxYXZ5dUdlYTJuSUNFc1JIRQo4TTJ0ZHp3cEdQN29JeTJxSEJGSkorM0F3bXdRQTREam1Ea0p0Q0QrNThhd29oUWF2Uk5ocWpzR0QrWmlmRzNWClI0aTZXckt2OE9XcVp6Y1pqM2czRWxyNStmUk1sejFHU3FrV1BCdzFFdjhLV1RIYXpTVUtGN09NeG0zWHp5WHgKUW53N2ZaRjlHT1Z0eDNhZHBmUlBxWUdndGJPUDM0RVZrejR3c0h2Tk1ydlVyWWNLeW1kT3Jua1RqbFgyNmZJSApVSnBLR1lrTGs5cTBqaE1OS3M0Um44bGo0cEo3WUYzMy9ORDRianBWMGV4MUVBUXowaVp2VDM3T254Tml1QVovCis0RGpmMDc1VXVOWDJlY1duYWRPck4xcjhOQVBhclpJd1VvU1VuV2hVOFRxQVdXUnF6RlVSSFVadU9NUWNBMGcKZWc0Yzl6cXRCb1VQZ3RRa3NiSUFFc0VYbUR1UnB3U0lGakVrSzExZjVFZW1mbWZkZzM3S3lJalE2N1RSVG1CQQora1Q5UTVKSW0vZTdtMUlMZy9IS2NrZ0xVT0NuQU1zQ0F3RUFBYU0yTURRd0R3WURWUjBUQVFIL0JBVXdBd0VCCi96QVJCZ05WSFE0RUNnUUlUanRJTmx6aVgzMHdEZ1lEVlIwUEFRSC9CQVFEQWdFR01BMEdDU3FHU0liM0RRRUIKQ3dVQUE0SUNBUUNkYkU4ZDFjMUR5c0t0cnRZbEFwWUlYVGxZM04yWEhOUTZnS29hVldzS2ExVEovb3ZyVCtGVgozYm1RTGV0M2FTb0VHNnBUZS92TFpTZzhXaUY3Y243V3VGNFhsUVMzeUEyVXU4L2NnL1M0b3dxaFFKcDZLL1hnCjZVb1NCYWQ5S29nMUg4ZGVPZlY4Tm1iOGE4OXpCNFlmOC9BZXBJZCtMci8zSTZPN2l1YitQVVQyUUJYbmtzYSsKY2YweWYrNDlHaHlNQ0lMWnZjdE5TUWQ0VnhyOUVnUnZCQVJUckFnTlE5c0VPSjZteU96NGlURlI3VDJwSUZQOApDcDE1ZThqRVZJMXE0SXVIdTNYbHdKTms5ZjVrM2did3J6b3k5UDVyUDh2b1FVM3U5d2g2MkpaYTlVNjNiK3UvClVyMXRzS2I1THgwWVVlZHRIdnBJaUlSdXJFUHh1bVcwdHdqcng4VHJBY1hSclZpU0w3ZHNYQW9ZQzBkWG8xNTQKRUU4akJBemdJSXVyN3RKaXp4Z1hERW40aTJwdThZZDYxNVlNTDlpaTVCb29FSjJqNmZRMG56eVBSbXgxRWd3MgpGamxnenpjZWFpNFRVT2NhQ0thYjg2eXl1NU1aSXArQmlQUjg0MG53NU1nZ2JSZ1lIMm5GUkJBNzB0b1ZtNFZGCmxiWnMzcmVHbWFJQ200U1Q2UjM5NU94WVMxaVlCbTVrWG05dExiNHBrSWhVeHJrZ3l1aXdFK0RzV2NlQmpIQVkKYVhuQ2dVR0t0aUc5dGZCTVV3M2ZDaG9QYjlMMXlLZE5vZjN6WERkVGxvTXFFcE80QkZybWpjbzhrdDF2MExVUQpQaE5abVFQNG5xZDRIcXgyMzg0blBtV0RYYlErZWVQeXhSdGVZR1kwaEplRExWcHllWUc4VlE9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCkJhZyBBdHRyaWJ1dGVzCiAgICAxLjMuNi4xLjQuMS4zMTEuMTcuMy43NTogNDYgMDAgNDYgMDAgNDMgMDAgMzUgMDAgMzYgMDAgNDIgMDAgNDUgMDAgNDUgMDAgNDMgMDAgNDYgMDAgMzkgMDAgNDYgMDAgMzggMDAgNDYgMDAgMzYgMDAgNDUgMDAgNDMgMDAgMzUgMDAgMzggMDAgMzIgMDAgNDIgMDAgNDYgMDAgMzEgMDAgMzYgMDAgNDYgMDAgMzAgMDAgMzEgMDAgMzUgMDAgNDMgMDAgMzEgMDAgMzAgMDAgMzAgMDAgNUYgMDAgMDAgMDAgCnN1YmplY3Q9QyA9IElOLCBPID0gZU11ZGhyYSBMaW1pdGVkLCBPVSA9IENlcnRpZnlpbmcgQXV0aG9yaXR5LCBwb3N0YWxDb2RlID0gNTYwMTAzLCBTVCA9IEthcm5hdGFrYSwgc3RyZWV0ID0gQmVuZ2FsdXJ1LCBob3VzZUlkZW50aWZpZXIgPSAiM3JkIEZsb29yLFNhaSBBcmNhZGUiLCBDTiA9IGUtTXVkaHJhIENBIDIwMjIKaXNzdWVyPUMgPSBJTiwgTyA9IEluZGlhIFBLSSwgQ04gPSBDQ0EgSW5kaWEgMjAyMgotLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS0KTUlJRnV6Q0NBNk9nQXdJQkFnSVFUTDV6RVh5azQ3R3REQ20yMEtnWW9UQU5CZ2txaGtpRzl3MEJBUXNGQURBNgpNUXN3Q1FZRFZRUUdFd0pKVGpFU01CQUdBMVVFQ2hNSlNXNWthV0VnVUV0Sk1SY3dGUVlEVlFRREV3NURRMEVnClNXNWthV0VnTWpBeU1qQWVGdzB5TWpBeU1UWXhNVEU0TURkYUZ3MHpNakF5TVRZeE1URTRNRGRhTUlHNU1Rc3cKQ1FZRFZRUUdFd0pKVGpFWU1CWUdBMVVFQ2hNUFpVMTFaR2h5WVNCTWFXMXBkR1ZrTVIwd0d3WURWUVFMRXhSRApaWEowYVdaNWFXNW5JRUYxZEdodmNtbDBlVEVQTUEwR0ExVUVFUk1HTlRZd01UQXpNUkl3RUFZRFZRUUlFd2xMCllYSnVZWFJoYTJFeEVqQVFCZ05WQkFrVENVSmxibWRoYkhWeWRURWRNQnNHQTFVRU14TVVNM0prSUVac2IyOXkKTEZOaGFTQkJjbU5oWkdVeEdUQVhCZ05WQkFNVEVHVXRUWFZrYUhKaElFTkJJREl3TWpJd2dnRWlNQTBHQ1NxRwpTSWIzRFFFQkFRVUFBNElCRHdBd2dnRUtBb0lCQVFDblhpaFhteGx3UlE2ejd1QjFXZ1RTOXduYnQ0NTE3SDMxCkF1Qk9heGpEU29qcWxXTHRIcCtEMXVVYVBOcDUxZkRsVWgwUVV2L3FhRzF4aDZkRWpaRWNnQzQrdzg3eENDWFAKd3RFYmdYaUhXSEVOZnRpQ3hZbWNyeDNTbDd0b2V2L2czSmIzK0xsNW9KTWYrY1c0dm1aeEQ5QW1idHdjQVZmNApBaGN3d1c2QytJc1UyOXgvZXlGeklQYkRzRnhUSmVSd21wbVVMc1p4eWpIQXdJS1VaWURjRnhDRUdaSFlKU0ZyCkEyUkZDZXg0MkxXemhBZU1mZ2dEZFk5QU5LTGlDTWw2a3pHOGcraC9jT1pxdHFISlhGOE91QUN1RUdCV2h6WW4KNEZqbmN3djlzT2xjSlJndUx0ZnY5UmxBQ0QybVRYWitnN1p2T01ZZkpCLzFjb3k3MGhaeEFnTUJBQUdqZ2dFNwpNSUlCTnpBU0JnTlZIUk1CQWY4RUNEQUdBUUgvQWdFQk1CMEdBMVVkRGdRV0JCUUU0TGwwZk1DUy8rOXZ4TlkxCkpQKzYvUkE2VERBU0JnTlZIU0FFQ3pBSk1BY0dCV0NDWkdRQ01CTUdBMVVkSXdRTU1BcUFDRTQ3U0RaYzRsOTkKTUlHQUJnZ3JCZ0VGQlFjQkFRUjBNSEl3SGdZSUt3WUJCUVVITUFHR0VtaDBkSEE2THk5dlkzWnpMbWR2ZGk1cApiakJRQmdnckJnRUZCUWN3QW9aRWFIUjBjRG92TDNkM2R5NWpZMkV1WjI5MkxtbHVMMk5qWVM5emFYUmxjeTlrClpXWmhkV3gwTDJacGJHVnpMMlpwYkdWekwwTkRRVWx1WkdsaE1qQXlNaTVqWlhJd0RnWURWUjBQQVFIL0JBUUQKQWdFR01FWUdBMVVkSHdRL01EMHdPNkE1b0RlR05XaDBkSEE2THk5alkyRXVaMjkyTG1sdUwzSjNMM0psYzI5MQpjbU5sY3k5RFEwRkpibVJwWVRJd01qSk1ZWFJsYzNRdVkzSnNNQTBHQ1NxR1NJYjNEUUVCQ3dVQUE0SUNBUUJQCnIxRWRNQkZVditCSEo5VU1oMEVSbHNSSGZyc2g2V1VEOHB2RitkK0hEdlR5OUtHYWo2L0xnajZSbXRDVGdkT3QKT0RvK0hNSEVNcWcwSU5RWmNHVlJFSGxrOXF1cURhTjFxTnFFeVdOOThQdFdJUVFxV3FVWkNGRVNFSFltMm1YawoyNGgvT3NqRUlvTys1WnRQaU4vbDR1OVJxV2FzcWpuYWtHdENjbzdyM0c2UU5NRm5iSTVyMm5CVURhNHRRZW1JCkUxd2J4Znp5dDFWeUNON1NQYmZCS3VNVmdNakkyK1paOWxaRkNTYWhFb0lEUWVNd2lYUEdRRk0vYlo4UXJQOTcKc2YyTGtaaXZEaE5UOVFjZ0R5UVFtZlBobk85dTJNN2FTdVVYNXRmOUNEWnVzUmRYL1g0eWFuVjNjZVEwWGdsNgovb3pFbkcxa0NpOEJSMlNWUzlGc3hzK3ZwNUdiN1BDZ2dRTHFsVjBocTNFR3FZTzh5NmxtV0hHb0ZIVDAxMnRSCkRwakI0UmRBNFhoVGZaN1pmcnlyS2U5bnd5dWg1NXIrRllGUnpXSWlWMnhlV1NtVTFobE5qblVuVm04ZEVQZG4KMzRZdWEzWUFuU0hUOWJzbHA5ZzJJT1RjK2EzcHFmbjVWcDRHR29JU0E3WmRHME90M056ZDBsNkVSdTFCN3JjSQoyNXFGcVZORkFiQW9yMXV4NlZRSjVQbVRySTNDWWkzTGRpRWw2bEJ5OFNEOFFKdm41c0w5VE12bFVqWUJCUFlWCmppNmRNbWRYZHpyZkpHOWxkV29PZ1pDZWhLNFpaY3JXaVJibzZXY3FYS3YxeTZIcWpOSE5QNzhOaFRYYlZoVTYKZ3VBeURvVVRiQW1xRzdCOWkrN0paSm9rZXIyZE45eDErZU14V1BvQnV3PT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQpCYWcgQXR0cmlidXRlcwogICAgMS4zLjYuMS40LjEuMzExLjE3LjMuNzU6IDMyIDAwIDMxIDAwIDQ1IDAwIDMwIDAwIDQzIDAwIDMzIDAwIDQzIDAwIDM2IDAwIDQ1IDAwIDMyIDAwIDM2IDAwIDQzIDAwIDQxIDAwIDQxIDAwIDQyIDAwIDM3IDAwIDM4IDAwIDM5IDAwIDM4IDAwIDQ0IDAwIDM0IDAwIDMwIDAwIDQzIDAwIDQyIDAwIDM1IDAwIDMwIDAwIDM0IDAwIDQ2IDAwIDM1IDAwIDMzIDAwIDM2IDAwIDQ1IDAwIDVGIDAwIDAwIDAwIApzdWJqZWN0PUMgPSBJTiwgTyA9IGVNdWRocmEgTGltaXRlZCwgT1UgPSBDZXJ0aWZ5aW5nIEF1dGhvcml0eSwgQ04gPSBlLU11ZGhyYSBTdWIgQ0EgZm9yIENsYXNzIDIgRG9jdW1lbnQgU2lnbmVyIDIwMjIKaXNzdWVyPUMgPSBJTiwgTyA9IGVNdWRocmEgTGltaXRlZCwgT1UgPSBDZXJ0aWZ5aW5nIEF1dGhvcml0eSwgcG9zdGFsQ29kZSA9IDU2MDEwMywgU1QgPSBLYXJuYXRha2EsIHN0cmVldCA9IEJlbmdhbHVydSwgaG91c2VJZGVudGlmaWVyID0gIjNyZCBGbG9vcixTYWkgQXJjYWRlIiwgQ04gPSBlLU11ZGhyYSBDQSAyMDIyCi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLQpNSUlGQkRDQ0EreWdBd0lCQWdJRUFWSnlSREFOQmdrcWhraUc5dzBCQVFzRkFEQ0J1VEVMTUFrR0ExVUVCaE1DClNVNHhHREFXQmdOVkJBb1REMlZOZFdSb2NtRWdUR2x0YVhSbFpERWRNQnNHQTFVRUN4TVVRMlZ5ZEdsbWVXbHUKWnlCQmRYUm9iM0pwZEhreER6QU5CZ05WQkJFVEJqVTJNREV3TXpFU01CQUdBMVVFQ0JNSlMyRnlibUYwWVd0aApNUkl3RUFZRFZRUUpFd2xDWlc1bllXeDFjblV4SFRBYkJnTlZCRE1URkROeVpDQkdiRzl2Y2l4VFlXa2dRWEpqCllXUmxNUmt3RndZRFZRUURFeEJsTFUxMVpHaHlZU0JEUVNBeU1ESXlNQjRYRFRJeU1ESXhPREV5TXpReU1Gb1gKRFRNeU1ESXhOVEV5TXpReU1Gb3dnWUV4Q3pBSkJnTlZCQVlUQWtsT01SZ3dGZ1lEVlFRS0V3OWxUWFZrYUhKaApJRXhwYldsMFpXUXhIVEFiQmdOVkJBc1RGRU5sY25ScFpubHBibWNnUVhWMGFHOXlhWFI1TVRrd053WURWUVFECkV6QmxMVTExWkdoeVlTQlRkV0lnUTBFZ1ptOXlJRU5zWVhOeklESWdSRzlqZFcxbGJuUWdVMmxuYm1WeUlESXcKTWpJd2dnRWlNQTBHQ1NxR1NJYjNEUUVCQVFVQUE0SUJEd0F3Z2dFS0FvSUJBUUNwVFE5dWZNTDJmNkpKK3JSKwpLUlAwV0NTV1dKaVAwb09wNFRNbVUvRVVvTmE1Qk9FVFpDWnFZTlRySTgyWUlDdTVKVW1hR0RMaGl1VTZVTnpXCno1WFphbEpSZldYSnNVMlVMSjQvSmphcm5ycVA3YUpVc1JRWk15ZlhUai9qRWlpcW1uWm1pSmJZNUxxaHhJRjIKVC9jOFBUWHVINzVXRDF1dkN2cTcwU05vclV0djJxdlhTQmJSSVNoWnMyc01MMUFrdjhidXo3Y0NpeWhlekJJUwptMFYrVlFWNGRaczN6RFFWTENlQldaZ2p5cDdDblJ2UlFTVEVQa0JTajU3dEdia3AxRk02a2d1eERyQXAzQS9LCmpOVWlna3JvVzFsZVFhbVhyejJxc3hwUUhzVkkxdHNubHFQOVBUVld0Z2ZvdHdiZ3lSbXV5Q2Y4NWpWNy9mV1kKa1VVbEFnTUdWVGVqZ2dGSU1JSUJSREFmQmdOVkhTTUVHREFXZ0JRRTRMbDBmTUNTLys5dnhOWTFKUCs2L1JBNgpUREFkQmdOVkhRNEVGZ1FVcS8rdXcxMm0wdTA4RkFFOFZSMXJVMTdxeSswd0VnWURWUjBUQVFIL0JBZ3dCZ0VCCi93SUJBREFPQmdOVkhROEJBZjhFQkFNQ0FRWXdFZ1lEVlIwZ0JBc3dDVEFIQmdWZ2dtUmtBakIrQmdnckJnRUYKQlFjQkFRUnlNSEF3SkFZSUt3WUJCUVVITUFHR0dHaDBkSEE2THk5dlkzTndMbVV0YlhWa2FISmhMbU52YlRCSQpCZ2dyQmdFRkJRY3dBb1k4YUhSMGNEb3ZMM2QzZHk1bExXMTFaR2h5WVM1amIyMHZjbVZ3YjNOcGRHOXllUzlqCllXTmxjblJ6TDJWdGRXUm9jbUZqWVRJd01qSXVZM0owTUVvR0ExVWRId1JETUVFd1A2QTlvRHVHT1doMGRIQTYKTHk5M2QzY3VaUzF0ZFdSb2NtRXVZMjl0TDNKbGNHOXphWFJ2Y25rdlkzSnNjeTlsYlhWa2FISmhZMkV5TURJeQpMbU55YkRBTkJna3Foa2lHOXcwQkFRc0ZBQU9DQVFFQW1QWmZneDV6Z003RHBQWU43TDEzOUpMYVAzQ0E2L0IxCkpNcXJ5RGZDUGo5VkJFR3p1WDRkUW95T2N0dWNtVWNRYkZLcFkvM2FqbHRWeTRURDFNNnpxTkdtaGhIalZiK2YKTktpWjB2dnVFNVNZRVJ2VEZJejV2ck4yUGV3UDFsMnpzUzhFV3d5bzdlN1R6SXFVWlNvZFRWSUozLzJwMG9SYwpta0Vtd29VWDh1MzFieEtBQ1V2TTRWM0k3RkhVWG1lZUJCU2k3alNOdXJBelNjeDJ5QURvd2lNZHM2TThCdWtBCnlIYlQyV1dYR3ROdTFHR0dGVzdrekVOMFJKWUkwVWh6UG9SVVIyVTF0Vytmb3RHVGV3dTFFL0Z3NDhTQlFOQVAKRWF0US9xOHlhYlJsc1FGbllVeERSZzBUczY5YUM2Yk5LVGo5d0Z5aGpFa1RobUo4YjYxaUhnPT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo="

    # Convert source PDF to Base64
    # with open(r"C:\Users\ShyamSunderSingh\OneDrive - Proactive Data Systems Pvt. Ltd\Azure Projects\Company Digital Signatures files\Source Path\Sample.pdf", "rb") as f:
    #     input_pdf_base64 = base64.b64encode(f.read()).decode("utf-8")
    
    input_pdf_base64 = req.Param_input_pdf_base64
    Approver_Name = req.Param_Approver_Name

    signed_pdf_base64 = create_signed_pdf_base64(Approver_Name,
        input_pdf_base64,
        private_key_base64,
        certificate_base64,
        ca_chain_base64
    )

    if signed_pdf_base64:
        with open(r"C:\Users\ShyamSunderSingh\OneDrive - Proactive Data Systems Pvt. Ltd\Azure Projects\Company Digital Signatures files\Destination Path\Signed_Sample.pdf", "wb") as f:
            f.write(base64.b64decode(signed_pdf_base64))
        print("✅ Signed PDF saved successfully.")
    else:
        print("❌ Signing failed. Check error logs above.")

    return SignResponse(signed_pdf_base64=signed_pdf_base64)
    